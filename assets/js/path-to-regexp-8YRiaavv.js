var $={};Object.defineProperty($,"__esModule",{value:!0});$.TokenData=void 0;$.parse=R;var k=$.compile=O;$.match=F;$.pathToRegexp=S;const P="/",C=t=>t,I=new RegExp("^\\p{XID_Continue}$","u"),g="https://git.new/pathToRegexpError",M={"!":"!","@":"@",";":";",",":",","*":"*","+":"+","?":"?","{":"{","}":"}"};function U(t){const e=[...t],n=[];let r=0;for(;r<e.length;){const c=e[r],o=M[c];if(o){n.push({type:o,index:r++,value:c});continue}if(c==="\\"){n.push({type:"ESCAPED",index:r++,value:e[r++]});continue}if(c===":"){let a="";for(;I.test(e[++r]);)a+=e[r];if(!a)throw new TypeError(`Missing parameter name at ${r}`);n.push({type:"NAME",index:r,value:a});continue}if(c==="("){const a=r++;let p=1,i="";if(e[r]==="?")throw new TypeError(`Pattern cannot start with "?" at ${r}`);for(;r<e.length;){if(e[r]==="\\"){i+=e[r++]+e[r++];continue}if(e[r]===")"){if(p--,p===0){r++;break}}else if(e[r]==="("&&(p++,e[r+1]!=="?"))throw new TypeError(`Capturing groups are not allowed at ${r}`);i+=e[r++]}if(p)throw new TypeError(`Unbalanced pattern at ${a}`);if(!i)throw new TypeError(`Missing pattern at ${a}`);n.push({type:"PATTERN",index:r,value:i});continue}n.push({type:"CHAR",index:r,value:e[r++]})}return n.push({type:"END",index:r,value:""}),new _(n)}class _{constructor(e){this.tokens=e,this.index=0}peek(){return this.tokens[this.index]}tryConsume(e){const n=this.peek();if(n.type===e)return this.index++,n.value}consume(e){const n=this.tryConsume(e);if(n!==void 0)return n;const{type:r,index:c}=this.peek();throw new TypeError(`Unexpected ${r} at ${c}, expected ${e}: ${g}`)}text(){let e="",n;for(;n=this.tryConsume("CHAR")||this.tryConsume("ESCAPED");)e+=n;return e}modifier(){return this.tryConsume("?")||this.tryConsume("*")||this.tryConsume("+")}}class w{constructor(e,n){this.tokens=e,this.delimiter=n}}$.TokenData=w;function R(t,e={}){const{encodePath:n=C,delimiter:r=n(P)}=e,c=[],o=U(t);let a=0;do{const p=o.text();p&&c.push(n(p));const i=o.tryConsume("NAME"),l=o.tryConsume("PATTERN");if(i||l){c.push({name:i||String(a++),pattern:l});const s=o.peek();if(s.type==="*")throw new TypeError(`Unexpected * at ${s.index}, you probably want \`/*\` or \`{/:foo}*\`: ${g}`);continue}if(o.tryConsume("*")){c.push({name:String(a++),pattern:`(?:(?!${x(r)}).)*`,modifier:"*",separator:r});continue}if(o.tryConsume("{")){const s=o.text(),d=o.tryConsume("NAME"),m=o.tryConsume("PATTERN"),h=o.text(),y=o.tryConsume(";")&&o.text();o.consume("}");const E=o.modifier();c.push({name:d||(m?String(a++):""),prefix:n(s),suffix:n(h),pattern:m,modifier:E,separator:y});continue}o.consume("END");break}while(!0);return new w(c,r)}function O(t,e={}){const n=t instanceof w?t:R(t,e);return L(n,e)}function j(t,e){if(typeof t=="string")return()=>t;const n=e||C,r=t.modifier==="+"||t.modifier==="*",c=t.modifier==="?"||t.modifier==="*",{prefix:o="",suffix:a="",separator:p=a+o}=t;if(e&&r){const l=(f,s)=>{if(typeof f!="string")throw new TypeError(`Expected "${t.name}/${s}" to be a string`);return n(f)},u=f=>{if(!Array.isArray(f))throw new TypeError(`Expected "${t.name}" to be an array`);return f.length===0?"":o+f.map(l).join(p)+a};return c?f=>{const s=f[t.name];return s==null?"":s.length?u(s):""}:f=>{const s=f[t.name];return u(s)}}const i=l=>{if(typeof l!="string")throw new TypeError(`Expected "${t.name}" to be a string`);return o+n(l)+a};return c?l=>{const u=l[t.name];return u==null?"":i(u)}:l=>{const u=l[t.name];return i(u)}}function L(t,e){const{encode:n=encodeURIComponent,loose:r=!0,validate:c=!0,strict:o=!1}=e,a=D(e),p=v(r,t.delimiter),i=N(t,p,[],a,o),l=t.tokens.map((u,f)=>{const s=j(u,n);if(!c||typeof u=="string")return s;const d=new RegExp(`^${i[f]}$`,a);return m=>{const h=s(m);if(!d.test(h))throw new TypeError(`Invalid value for "${u.name}": ${JSON.stringify(h)}`);return h}});return function(f={}){let s="";for(const d of l)s+=d(f);return s}}function F(t,e={}){const{decode:n=decodeURIComponent,loose:r=!0,delimiter:c=P}=e,o=S(t,e),a=v(r,c),p=o.keys.map(i=>{if(n&&(i.modifier==="+"||i.modifier==="*")){const{prefix:l="",suffix:u="",separator:f=u+l}=i,s=new RegExp(a(f),"g");return d=>d.split(s).map(n)}return n||C});return function(l){const u=o.exec(l);if(!u)return!1;const{0:f,index:s}=u,d=Object.create(null);for(let m=1;m<u.length;m++){if(u[m]===void 0)continue;const h=o.keys[m-1],y=p[m-1];d[h.name]=y(u[m])}return{path:f,index:s,params:d}}}function x(t){return t.replace(/[.+*?^${}()[\]|/\\]/g,"\\$&")}function H(t,e){const n=x(t);return e?`(?:${n})+(?!${n})`:n}function v(t,e){if(!t)return x;const n=new RegExp(`(?:(?!${x(e)}).)+|(.)`,"g");return r=>r.replace(n,H)}function D(t){return t.sensitive?"":"i"}function b(t,e,n,r){const c=t instanceof w?t:R(t,r),{trailing:o=!0,loose:a=!0,start:p=!0,end:i=!0,strict:l=!1}=r,u=v(a,c.delimiter),f=N(c,u,e,n,l);let s=p?"^":"";return s+=f.join(""),o&&(s+=`(?:${u(c.delimiter)}$)?`),s+=i?"$":`(?=${x(c.delimiter)}|$)`,s}function N(t,e,n,r,c){const o=`(?:(?!${x(t.delimiter)}).)+?`;let a="",p=!0;return t.tokens.map(i=>{if(typeof i=="string")return a=i,e(i);const{prefix:l="",suffix:u="",separator:f=u+l,modifier:s=""}=i,d=e(l),m=e(u);if(i.name){const h=i.pattern?`(?:${i.pattern})`:o,y=V(h,i.name,r);if(p||(p=T(y,l||a)),!p)throw new TypeError(`Ambiguous pattern for "${i.name}": ${g}`);if(p=!c||T(y,u),a="",n.push(i),s==="+"||s==="*"){const E=s==="*"?"?":"",A=e(f);if(!A)throw new TypeError(`Missing separator for "${i.name}": ${g}`);if(p||(p=!c||T(y,f)),!p)throw new TypeError(`Ambiguous pattern for "${i.name}" separator: ${g}`);return p=!c,`(?:${d}(${h}(?:${A}${h})*)${m})${E}`}return`(?:${d}(${h})${m})${s}`}return`(?:${d}${m})${s}`})}function V(t,e,n){try{return new RegExp(`^${t}$`,n)}catch(r){throw new TypeError(`Invalid pattern for "${e}": ${r.message}`)}}function T(t,e){return e?!t.test(e):!1}function S(t,e={}){const n=[],r=D(e);if(Array.isArray(t)){const o=t.map(a=>b(a,n,r,e));return Object.assign(new RegExp(o.join("|")),{keys:n})}const c=b(t,n,r,e);return Object.assign(new RegExp(c),{keys:n})}export{k as c};
